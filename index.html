<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>JK BMS Monitor</title>
<meta name="theme-color" content="#0f172a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<style>
:root {
  --bg: #0f172a; --surface: #1e293b; --surface2: #334155;
  --text: #f1f5f9; --text2: #94a3b8; --text3: #64748b;
  --green: #22c55e; --green-dim: #16a34a; --green-bg: rgba(34,197,94,0.1);
  --red: #ef4444; --red-bg: rgba(239,68,68,0.1);
  --yellow: #eab308; --yellow-bg: rgba(234,179,8,0.1);
  --blue: #3b82f6; --blue-bg: rgba(59,130,246,0.1);
  --orange: #f97316;
  --radius: 12px; --gap: 12px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg); color: var(--text); line-height: 1.5;
  min-height: 100vh; min-height: 100dvh;
  -webkit-font-smoothing: antialiased;
}
.container { max-width: 600px; margin: 0 auto; padding: 16px; padding-bottom: 80px; }

/* Header */
header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 0; margin-bottom: 12px; border-bottom: 1px solid var(--surface2);
}
header h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.3px; }
header h1 span { color: var(--green); }
.status-dot {
  width: 10px; height: 10px; border-radius: 50%;
  background: var(--text3); display: inline-block; margin-right: 8px;
  transition: background 0.3s;
}
.status-dot.connected { background: var(--green); box-shadow: 0 0 8px var(--green); }
.status-dot.connecting { background: var(--yellow); animation: pulse 1s infinite; }
@keyframes pulse { 50% { opacity: 0.4; } }

/* Buttons */
.btn {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 10px 20px; border: none; border-radius: 8px;
  font-size: 14px; font-weight: 600; cursor: pointer;
  transition: all 0.15s; font-family: inherit;
}
.btn-primary { background: var(--green); color: #000; }
.btn-primary:hover { background: var(--green-dim); }
.btn-primary:disabled { background: var(--surface2); color: var(--text3); cursor: not-allowed; }
.btn-danger { background: var(--red); color: #fff; }
.btn-sm { padding: 6px 14px; font-size: 13px; }
.btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--surface2); }

/* Cards */
.card {
  background: var(--surface); border-radius: var(--radius);
  padding: 16px; margin-bottom: var(--gap);
}
.card-title {
  font-size: 11px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.8px; color: var(--text3); margin-bottom: 12px;
}

/* Connect section */
#connect-section { text-align: center; padding: 40px 0; }
#connect-section p { color: var(--text2); margin: 8px 0 20px; font-size: 14px; }
.device-name { font-size: 14px; color: var(--text2); }

/* Stats grid */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); margin-bottom: var(--gap); }
.stat-card {
  background: var(--surface); border-radius: var(--radius); padding: 14px;
}
.stat-label { font-size: 11px; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; }
.stat-value { font-size: 26px; font-weight: 700; letter-spacing: -1px; margin: 4px 0 0; }
.stat-unit { font-size: 13px; font-weight: 400; color: var(--text2); }
.stat-value.green { color: var(--green); }
.stat-value.blue { color: var(--blue); }
.stat-value.yellow { color: var(--yellow); }
.stat-value.red { color: var(--red); }

/* SOC gauge */
.soc-card { grid-column: 1 / -1; }
.soc-bar-outer {
  height: 24px; background: var(--surface2); border-radius: 12px;
  overflow: hidden; margin-top: 8px;
}
.soc-bar-inner {
  height: 100%; border-radius: 12px;
  background: linear-gradient(90deg, var(--red), var(--yellow) 30%, var(--green) 60%);
  transition: width 0.5s ease;
  display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;
  font-size: 12px; font-weight: 700; color: #000; min-width: 40px;
}

/* Cell voltages */
.cells-container { display: flex; flex-direction: column; gap: 4px; }
.cell-row {
  display: grid; grid-template-columns: 40px 1fr 60px; align-items: center; gap: 8px;
  font-size: 13px;
}
.cell-label { color: var(--text3); font-weight: 500; }
.cell-bar-outer {
  height: 16px; background: var(--surface2); border-radius: 4px; overflow: hidden;
}
.cell-bar-inner {
  height: 100%; border-radius: 4px; transition: width 0.3s, background 0.3s;
  min-width: 2px;
}
.cell-bar-inner.low { background: var(--red); }
.cell-bar-inner.mid { background: var(--yellow); }
.cell-bar-inner.ok { background: var(--green); }
.cell-bar-inner.high { background: var(--orange); }
.cell-value { text-align: right; font-variant-numeric: tabular-nums; font-weight: 500; }

/* Temp grid */
.temp-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 8px; }
.temp-item {
  background: var(--surface2); border-radius: 8px; padding: 10px;
  text-align: center;
}
.temp-label { font-size: 11px; color: var(--text3); }
.temp-value { font-size: 18px; font-weight: 700; margin-top: 2px; }
.temp-value.hot { color: var(--red); }
.temp-value.warm { color: var(--orange); }
.temp-value.normal { color: var(--green); }

/* Protection flags */
.prot-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.prot-item {
  font-size: 12px; padding: 6px 8px; border-radius: 6px;
  display: flex; align-items: center; gap: 6px;
}
.prot-item.ok { background: var(--green-bg); color: var(--green); }
.prot-item.alert { background: var(--red-bg); color: var(--red); font-weight: 600; }
.prot-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
.prot-item.ok .prot-dot { background: var(--green); }
.prot-item.alert .prot-dot { background: var(--red); }

/* MOS status */
.mos-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px; }
.mos-item {
  text-align: center; padding: 10px; border-radius: 8px; border: 1px solid var(--surface2);
}
.mos-item.on { border-color: var(--green); background: var(--green-bg); }
.mos-item.off { border-color: var(--red); background: var(--red-bg); }
.mos-label { font-size: 11px; color: var(--text3); }
.mos-state { font-size: 14px; font-weight: 700; margin-top: 2px; }
.mos-item.on .mos-state { color: var(--green); }
.mos-item.off .mos-state { color: var(--red); }

/* Device info rows */
.info-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 0; border-bottom: 1px solid var(--surface);
}
.info-row:last-child { border-bottom: none; }
.info-label { font-size: 13px; color: var(--text3); }
.info-value { font-size: 13px; color: var(--text); font-weight: 500; font-family: 'SF Mono', monospace; }

/* Hex dump */
.hex-toggle {
  width: 100%; text-align: left; background: var(--surface);
  border: none; color: var(--text2); font-size: 13px;
  padding: 12px 16px; border-radius: var(--radius);
  cursor: pointer; font-family: inherit; font-weight: 600;
  display: flex; justify-content: space-between;
}
.hex-toggle .arrow { transition: transform 0.2s; }
.hex-toggle.open .arrow { transform: rotate(90deg); }
.hex-dump {
  display: none; background: var(--surface); border-radius: 0 0 var(--radius) var(--radius);
  padding: 12px; margin-top: -12px; margin-bottom: var(--gap);
  max-height: 300px; overflow-y: auto;
}
.hex-dump.show { display: block; }
.hex-dump pre {
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 11px; line-height: 1.6; color: var(--text2);
  white-space: pre-wrap; word-break: break-all;
}
.hex-dump .offset { color: var(--text3); }
.hex-dump .header-bytes { color: var(--blue); }
.hex-dump .data-bytes { color: var(--text); }
.hex-dump .crc-bytes { color: var(--yellow); }

/* Log */
.log {
  background: var(--surface); border-radius: var(--radius);
  padding: 12px; max-height: 200px; overflow-y: auto;
  font-family: monospace; font-size: 11px; line-height: 1.6;
}
.log-entry { color: var(--text3); }
.log-entry.info { color: var(--blue); }
.log-entry.ok { color: var(--green); }
.log-entry.warn { color: var(--yellow); }
.log-entry.error { color: var(--red); }

/* Tabs */
.tabs { display: flex; gap: 4px; margin-bottom: var(--gap); }
.tab {
  flex: 1; text-align: center; padding: 8px; border: none;
  background: var(--surface); color: var(--text3);
  font-size: 13px; font-weight: 600; cursor: pointer;
  border-radius: 8px; font-family: inherit;
  transition: all 0.15s;
}
.tab.active { background: var(--green-bg); color: var(--green); }

.hidden { display: none !important; }

/* Unsupported browser warning */
.warning-banner {
  background: var(--yellow-bg); border: 1px solid var(--yellow);
  color: var(--yellow); padding: 12px; border-radius: 8px;
  font-size: 13px; margin-bottom: 16px; text-align: center;
}

/* Frame counter */
.frame-counter {
  font-size: 11px; color: var(--text3); text-align: center;
  margin-bottom: 8px;
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><span>&#9889;</span> JK BMS Monitor</h1>
    <div id="header-status">
      <span class="status-dot" id="status-dot"></span>
      <span id="status-text" style="font-size:13px; color:var(--text2)">Disconnected</span>
    </div>
  </header>

  <div id="browser-warning" class="warning-banner hidden">
    Web Bluetooth is not supported in this browser. Use Chrome, Edge, or Opera on Android/Desktop.
  </div>

  <!-- Connect Screen -->
  <div id="connect-section">
    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="1.5">
      <path d="M6.5 6.5l11 11M6.5 17.5l11-11M12 2v20"/>
      <rect x="4" y="7" width="16" height="10" rx="2" stroke="#334155"/>
      <rect x="20" y="10" width="2" height="4" rx="0.5" fill="#334155" stroke="none"/>
    </svg>
    <p>Connect to your JK BMS via Bluetooth Low Energy</p>
    <button class="btn btn-primary" id="btn-scan" onclick="startScan()">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6.5 6.5l11 11M6.5 17.5l11-11M12 2v20"/></svg>
      Scan for BMS
    </button>
  </div>

  <!-- Dashboard (hidden until connected) -->
  <div id="dashboard" class="hidden">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px">
      <div>
        <div class="device-name" id="device-name">—</div>
      </div>
      <button class="btn btn-danger btn-sm" onclick="disconnect()">Disconnect</button>
    </div>

    <div class="frame-counter" id="frame-counter">Waiting for data...</div>

    <!-- SOC -->
    <div class="stat-card soc-card" style="margin-bottom:var(--gap)">
      <div style="display:flex; justify-content:space-between; align-items:baseline">
        <div class="stat-label">State of Charge</div>
        <div style="font-size:13px; color:var(--text2)">
          <span id="soc-remain">—</span> / <span id="soc-full">—</span> Ah
        </div>
      </div>
      <div class="soc-bar-outer">
        <div class="soc-bar-inner" id="soc-bar" style="width:0%">0%</div>
      </div>
    </div>

    <!-- Stats -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Pack Voltage</div>
        <div class="stat-value blue" id="pack-voltage">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Current</div>
        <div class="stat-value green" id="pack-current">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Power</div>
        <div class="stat-value yellow" id="pack-power">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Cycles</div>
        <div class="stat-value" id="pack-cycles" style="color:var(--text)">—</div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" onclick="showTab('cells',this)">Cells</button>
      <button class="tab" onclick="showTab('temps',this)">Temps</button>
      <button class="tab" onclick="showTab('status',this)">Status</button>
      <button class="tab" onclick="showTab('raw',this)">Raw</button>
    </div>

    <!-- Cells Tab -->
    <div id="tab-cells" class="card">
      <div style="display:flex; justify-content:space-between; margin-bottom:8px">
        <div class="card-title">Cell Voltages</div>
        <div style="font-size:12px; color:var(--text3)">
          &#916; <span id="cell-delta">—</span> mV
        </div>
      </div>
      <div class="cells-container" id="cells-container">
        <div style="text-align:center; color:var(--text3); padding:20px; font-size:13px">
          Waiting for cell data...
        </div>
      </div>
    </div>

    <!-- Temps Tab -->
    <div id="tab-temps" class="card hidden">
      <div class="card-title">Temperatures</div>
      <div class="temp-grid" id="temp-grid">
        <div style="color:var(--text3); font-size:13px; grid-column:1/-1; text-align:center; padding:12px">
          Waiting for temperature data...
        </div>
      </div>
    </div>

    <!-- Status Tab -->
    <div id="tab-status" class="card hidden">
      <div class="card-title">Device Info</div>
      <div id="device-info-content" style="margin-bottom:12px">
        <div style="color:var(--text3); font-size:13px; text-align:center; padding:8px">
          Waiting for device info...
        </div>
      </div>
      <div class="card-title">MOS Status</div>
      <div class="mos-grid" id="mos-grid">
        <div class="mos-item"><div class="mos-label">Charge</div><div class="mos-state" id="mos-charge">—</div></div>
        <div class="mos-item"><div class="mos-label">Discharge</div><div class="mos-state" id="mos-discharge">—</div></div>
        <div class="mos-item"><div class="mos-label">Balance</div><div class="mos-state" id="mos-balance">—</div></div>
      </div>
      <div class="card-title" style="margin-top:12px">Alarm Status</div>
      <div id="alarm-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:6px">
        <div style="color:var(--text3); font-size:13px; grid-column:1/-1; text-align:center; padding:12px">
          No alarms
        </div>
      </div>
    </div>

    <!-- Raw Tab -->
    <div id="tab-raw" class="card hidden">
      <div class="card-title">Raw Frame Data</div>
      <div style="display:flex; gap:6px; margin-bottom:8px">
        <button class="btn btn-ghost btn-sm" onclick="sendActivate()">Send Activate</button>
        <button class="btn btn-ghost btn-sm" onclick="sendDeviceInfo()">Send Dev Info</button>
      </div>
      <div class="hex-dump show" id="hex-dump" style="margin-top:0; max-height:400px">
        <pre id="hex-content">No data received yet</pre>
      </div>
      <div class="card-title" style="margin-top:12px">Event Log</div>
      <div class="log" id="log-container"></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// JK BMS BLE Protocol Constants (based on esphome-jk-bms)
// Supports: JK02_24S, JK02_32S, JK04 protocol variants
// ============================================================
const BLE = {
  SERVICE: 0xFFE0,
  CHAR_NOTIFY: 0xFFE1,
  CHAR_WRITE: 0xFFE2,
  CMD_CELL_INFO: 0x96,   // Request cell info / activate
  CMD_DEVICE_INFO: 0x97,
  // Frame types are THE SAME for all protocol versions:
  FRAME_SETTINGS: 0x01,
  FRAME_CELL_DATA: 0x02,
  FRAME_DEVICE_INFO: 0x03,
  FRAME_SIZE: 300,             // All frames are 300 bytes, CRC at byte 299
  HEARTBEAT_INTERVAL: 5000,
};

// Protocol versions (auto-detected from device info)
const PROTO = {
  JK02_24S: 'jk02_24s',
  JK02_32S: 'jk02_32s',
  JK04:     'jk04',
};

// Error bit descriptions (from esphome)
const ERROR_BITS = [
  'Charge overtemp',           // bit 0
  'Charge undertemp',          // bit 1
  'Coprocessor comm error',    // bit 2
  'Cell undervoltage',         // bit 3
  'Pack undervoltage',         // bit 4
  'Discharge overcurrent',     // bit 5
  'Discharge short circuit',   // bit 6
  'Discharge overtemp',        // bit 7
  'Wire resistance',           // bit 8
  'MOSFET overtemp',           // bit 9
  'Cell count mismatch',       // bit 10
  'Current sensor anomaly',    // bit 11
  'Cell overvoltage',          // bit 12
  'Pack overvoltage',          // bit 13
  'Charge overcurrent',        // bit 14
  'Charge short circuit',      // bit 15
];

// ============================================================
// State
// ============================================================
let device = null;
let server = null;
let service = null;
let charNotify = null;
let charWrite = null;
let rxBuffer = [];
let frameCount = 0;
let lastFrameTime = 0;
let reconnecting = false;
let heartbeatTimer = null;
let protocolVersion = PROTO.JK02_32S; // Default; auto-detected from device info

let bmsData = {
  model: '', firmware: '', hardware: '', serial: '', deviceName: '',
  cells: [], resistances: [],
  avgCell: 0, deltaCell: 0, maxCellNo: 0, minCellNo: 0,
  temps: {}, packVoltage: 0, packCurrent: 0, packPower: 0,
  soc: 0, soh: 0, remainCap: 0, fullCap: 0, cycles: 0, cycleCap: 0, runtime: 0,
  balanceCurrent: 0, chargeMos: false, dischargeMos: false, balanceActive: false,
  heating: false, errorBitmask: 0, errorText: '',
};

// ============================================================
// Browser check
// ============================================================
if (!navigator.bluetooth) {
  document.getElementById('browser-warning').classList.remove('hidden');
  document.getElementById('btn-scan').disabled = true;
}

// ============================================================
// Logging
// ============================================================
function log(msg, level = '') {
  const el = document.getElementById('log-container');
  if (!el) return;
  const ts = new Date().toLocaleTimeString('en', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const div = document.createElement('div');
  div.className = 'log-entry ' + level;
  div.textContent = `[${ts}] ${msg}`;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
  // Keep max 200 entries
  while (el.children.length > 200) el.removeChild(el.firstChild);
}

// ============================================================
// BLE Connection
// ============================================================
async function startScan() {
  try {
    log('Scanning for JK BMS devices...', 'info');
    setStatus('connecting');

    device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [BLE.SERVICE] }],
      optionalServices: [BLE.SERVICE],
    });

    log(`Selected: ${device.name || 'Unknown'} (${device.id.slice(0,8)})`, 'ok');
    device.addEventListener('gattserverdisconnected', onDisconnected);

    await connectDevice();
  } catch (err) {
    if (err.name === 'NotFoundError') {
      log('Scan cancelled by user', 'warn');
    } else {
      log(`Scan error: ${err.message}`, 'error');
    }
    setStatus('disconnected');
  }
}

async function connectDevice() {
  try {
    setStatus('connecting');
    log('Connecting to GATT server...', 'info');

    server = await device.gatt.connect();
    log('GATT connected', 'ok');

    service = await server.getPrimaryService(BLE.SERVICE);
    log(`Service 0xFFE0 found`, 'ok');

    charNotify = await service.getCharacteristic(BLE.CHAR_NOTIFY);
    log(`Notify characteristic 0xFFE1 found`, 'ok');

    try {
      charWrite = await service.getCharacteristic(BLE.CHAR_WRITE);
      log(`Write characteristic 0xFFE2 found`, 'ok');
    } catch {
      // Some BMS models use FFE1 for both read and write
      charWrite = charNotify;
      log('Using 0xFFE1 for write (0xFFE2 not found)', 'warn');
    }

    await charNotify.startNotifications();
    charNotify.addEventListener('characteristicvaluechanged', onNotification);
    log('Notifications enabled', 'ok');

    setStatus('connected');
    document.getElementById('device-name').textContent = device.name || 'JK BMS';
    document.getElementById('connect-section').classList.add('hidden');
    document.getElementById('dashboard').classList.remove('hidden');

    // Send activate command to start data streaming
    await sleep(500);
    await sendActivate();

    // Start heartbeat — BMS disconnects if it doesn't receive
    // periodic activate commands (every ~5 seconds)
    if (heartbeatTimer) clearInterval(heartbeatTimer);
    heartbeatTimer = setInterval(async () => {
      if (charWrite) {
        try { await sendActivate(); } catch {}
      }
    }, BLE.HEARTBEAT_INTERVAL);
    log('Heartbeat started (every 5s)', 'ok');

  } catch (err) {
    log(`Connection error: ${err.message}`, 'error');
    setStatus('disconnected');
  }
}

function onDisconnected() {
  log('Device disconnected', 'warn');
  setStatus('disconnected');
  if (heartbeatTimer) { clearInterval(heartbeatTimer); heartbeatTimer = null; }
  charNotify = null;
  charWrite = null;

  if (!reconnecting) {
    reconnecting = true;
    log('Attempting reconnect in 3s...', 'info');
    setTimeout(async () => {
      reconnecting = false;
      if (device && device.gatt) {
        try { await connectDevice(); } catch { log('Reconnect failed', 'error'); }
      }
    }, 3000);
  }
}

async function disconnect() {
  if (heartbeatTimer) { clearInterval(heartbeatTimer); heartbeatTimer = null; }
  if (device && device.gatt.connected) {
    device.gatt.disconnect();
  }
  device = null;
  setStatus('disconnected');
  document.getElementById('connect-section').classList.remove('hidden');
  document.getElementById('dashboard').classList.add('hidden');
  rxBuffer = [];
  frameCount = 0;
}

function setStatus(state) {
  const dot = document.getElementById('status-dot');
  const text = document.getElementById('status-text');
  dot.className = 'status-dot ' + state;
  text.textContent = state === 'connected' ? 'Connected' :
                     state === 'connecting' ? 'Connecting...' : 'Disconnected';
}

// ============================================================
// BLE Commands
// ============================================================
function buildCommand(cmd) {
  const frame = new Uint8Array(20);
  frame[0] = 0xAA; frame[1] = 0x55; frame[2] = 0x90; frame[3] = 0xEB;
  frame[4] = cmd;
  // bytes 5-18 stay 0x00
  let sum = 0;
  for (let i = 0; i < 19; i++) sum += frame[i];
  frame[19] = sum & 0xFF;
  return frame;
}

async function sendCommand(data) {
  if (!charWrite) { log('Not connected', 'error'); return; }
  try {
    await charWrite.writeValueWithoutResponse(data);
    log(`TX: ${hex(data)}`, 'info');
  } catch (err) {
    // Fallback to writeValue if writeValueWithoutResponse not supported
    try {
      await charWrite.writeValue(data);
      log(`TX (with response): ${hex(data)}`, 'info');
    } catch (err2) {
      log(`Write failed: ${err2.message}`, 'error');
    }
  }
}

async function sendActivate() {
  const cmd = buildCommand(BLE.CMD_CELL_INFO);
  log('Sending cell info request (0x96)', 'info');
  await sendCommand(cmd);
}

async function sendDeviceInfo() {
  const cmd = buildCommand(BLE.CMD_DEVICE_INFO);
  log('Sending device info command (0x97)', 'info');
  await sendCommand(cmd);
}

// ============================================================
// Notification Handler & Frame Assembly
// ============================================================
function onNotification(event) {
  const value = new Uint8Array(event.target.value.buffer);
  // Append to receive buffer
  for (let i = 0; i < value.length; i++) rxBuffer.push(value[i]);

  // Try to extract complete frames
  extractFrames();
}

function extractFrames() {
  // esphome approach: flush buffer on preamble, frame is always 300 bytes
  while (rxBuffer.length >= BLE.FRAME_SIZE) {
    // Find header pattern 0x55 0xAA 0xEB 0x90
    let headerIdx = -1;
    for (let i = 0; i <= rxBuffer.length - 4; i++) {
      if (rxBuffer[i] === 0x55 && rxBuffer[i+1] === 0xAA &&
          rxBuffer[i+2] === 0xEB && rxBuffer[i+3] === 0x90) {
        headerIdx = i;
        break;
      }
    }

    if (headerIdx === -1) {
      if (rxBuffer.length > 3) rxBuffer = rxBuffer.slice(-3);
      return;
    }

    // Discard bytes before header
    if (headerIdx > 0) rxBuffer = rxBuffer.slice(headerIdx);

    // Need at least 300 bytes for a complete frame
    if (rxBuffer.length < BLE.FRAME_SIZE) return;

    // Extract 300-byte frame
    const frame = new Uint8Array(rxBuffer.slice(0, BLE.FRAME_SIZE));
    rxBuffer = rxBuffer.slice(BLE.FRAME_SIZE);

    // Verify CRC (sum of first 299 bytes, low byte)
    let crcCalc = 0;
    for (let i = 0; i < BLE.FRAME_SIZE - 1; i++) crcCalc += frame[i];
    crcCalc &= 0xFF;
    const crcRemote = frame[BLE.FRAME_SIZE - 1];

    if (crcCalc !== crcRemote) {
      log(`CRC mismatch: calc=0x${crcCalc.toString(16)} != recv=0x${crcRemote.toString(16)}`, 'warn');
      continue; // Try next frame
    }

    processFrame(frame);
  }
}

// ============================================================
// Frame Processing
// ============================================================
function processFrame(frame) {
  if (frame.length < 6) return;

  frameCount++;
  lastFrameTime = Date.now();
  const frameType = frame[4];

  document.getElementById('frame-counter').textContent =
    `Frame #${frameCount} | Type: 0x${frameType.toString(16).padStart(2,'0')} | ${frame.length} bytes | Proto: ${protocolVersion}`;

  updateHexDump(frame);

  switch (frameType) {
    case BLE.FRAME_SETTINGS:    // 0x01 — settings (all protocol versions)
      log(`Settings frame received (${frame.length} bytes)`, 'info');
      break;
    case BLE.FRAME_CELL_DATA:   // 0x02 — cell/realtime data
      parseCellData(frame);
      break;
    case BLE.FRAME_DEVICE_INFO: // 0x03 — device info
      parseDeviceInfo(frame);
      break;
    default:
      log(`Unknown frame type 0x${frameType.toString(16)} (${frame.length} bytes)`, 'warn');
  }
}

// ============================================================
// Helpers for reading protocol data
// ============================================================
function jkGet16(view, i) { return view.getUint16(i, true); }
function jkGet32(view, i) { return view.getUint32(i, true); }
function jkGetS16(view, i) { return view.getInt16(i, true); }
function jkGetS32(view, i) { return view.getInt32(i, true); }
function jkGetFloat(view, i) {
  // IEEE 754 float from 4 bytes little-endian
  return view.getFloat32(i, true);
}

function readString(frame, start, maxLen) {
  let s = '';
  for (let i = start; i < Math.min(start + maxLen, frame.length); i++) {
    if (frame[i] === 0) break;
    if (frame[i] >= 0x20 && frame[i] <= 0x7E) s += String.fromCharCode(frame[i]);
  }
  return s;
}

function errorBitsToString(bitmask) {
  const errors = [];
  for (let i = 0; i < ERROR_BITS.length; i++) {
    if (bitmask & (1 << i)) errors.push(ERROR_BITS[i]);
  }
  return errors.length > 0 ? errors.join(', ') : 'None';
}

// ============================================================
// Device Info Parser (Frame Type 0x03) — all protocols
// From esphome: fixed offsets at 6, 22, 30, 38, 42, 46, 62
// ============================================================
function parseDeviceInfo(frame) {
  if (frame.length < 70) {
    log(`Device info frame too short: ${frame.length} bytes`, 'warn');
    return;
  }

  const view = new DataView(frame.buffer);

  // Offset 6, 16 bytes: Vendor/model ID (e.g., "JK-B2A16S", "JK_PB2A16S15P")
  bmsData.model = readString(frame, 6, 16);

  // Offset 22, 8 bytes: Hardware version
  bmsData.hardware = readString(frame, 22, 8);

  // Offset 30, 8 bytes: Software/firmware version
  bmsData.firmware = readString(frame, 30, 8);

  // Offset 38, 4 bytes: Uptime in seconds (uint32 LE)
  const uptimeS = jkGet32(view, 38);

  // Offset 42, 4 bytes: Power on count (uint32 LE)
  const powerOnCount = jkGet32(view, 42);

  // Offset 46, 16 bytes: Device name
  bmsData.deviceName = readString(frame, 46, 16);

  // Offset 62, 16 bytes: Device passcode
  const passcode = readString(frame, 62, 16);

  // Offset 78, 8 bytes: Manufacturing date (JK02 variants)
  const mfgDate = readString(frame, 78, 8);

  // Offset 86, 10 bytes: Serial number (JK02 variants)
  bmsData.serial = readString(frame, 86, 11);

  // Auto-detect protocol from model string
  const model = bmsData.model;
  if (model.startsWith('JK_') || model.includes('PB')) {
    // JK_PBxxxx models use the JK02_32S protocol frame layout
    protocolVersion = PROTO.JK02_32S;
    log(`Auto-detected protocol: JK02_32S (model: ${model})`, 'ok');
  } else if (model.startsWith('JK-B') && /\d{2}S$/.test(model)) {
    // JK-B2AxxSxx models — check hardware version
    const hwMajor = parseInt(bmsData.hardware);
    if (hwMajor >= 11) {
      protocolVersion = PROTO.JK02_32S;
      log(`Auto-detected protocol: JK02_32S (HW ${bmsData.hardware})`, 'ok');
    } else if (hwMajor >= 3 && hwMajor < 11) {
      protocolVersion = PROTO.JK04;
      log(`Auto-detected protocol: JK04 (HW ${bmsData.hardware})`, 'ok');
    } else {
      protocolVersion = PROTO.JK02_24S;
      log(`Auto-detected protocol: JK02_24S (HW ${bmsData.hardware})`, 'ok');
    }
  }

  // Update header with model info
  const nameEl = document.getElementById('device-name');
  nameEl.textContent = bmsData.deviceName || bmsData.model || device?.name || 'JK BMS';

  // Update device info in status tab
  const infoEl = document.getElementById('device-info-content');
  if (infoEl) {
    infoEl.innerHTML = `
      <div class="info-row"><span class="info-label">Model</span><span class="info-value">${bmsData.model || '—'}</span></div>
      <div class="info-row"><span class="info-label">Hardware</span><span class="info-value">${bmsData.hardware || '—'}</span></div>
      <div class="info-row"><span class="info-label">Firmware</span><span class="info-value">${bmsData.firmware || '—'}</span></div>
      <div class="info-row"><span class="info-label">Serial</span><span class="info-value">${bmsData.serial || '—'}</span></div>
      <div class="info-row"><span class="info-label">Name</span><span class="info-value">${bmsData.deviceName || '—'}</span></div>
      <div class="info-row"><span class="info-label">Protocol</span><span class="info-value">${protocolVersion}</span></div>
    `;
  }

  log(`Model: ${bmsData.model} | FW: ${bmsData.firmware} | SN: ${bmsData.serial}`, 'ok');
}

// ============================================================
// Cell Data Parser (Frame Type 0x02) — dispatches by protocol
// ============================================================
function parseCellData(frame) {
  if (frame.length < 200) {
    log(`Cell data frame too short: ${frame.length} bytes`, 'warn');
    return;
  }

  if (protocolVersion === PROTO.JK04) {
    parseJK04CellInfo(frame);
  } else {
    parseJK02CellInfo(frame);
  }
}

// ============================================================
// JK02 Cell Info Parser (24S and 32S variants)
// Based on esphome decode_jk02_cell_info_
// ============================================================
function parseJK02CellInfo(frame) {
  const view = new DataView(frame.buffer);
  const is32S = (protocolVersion === PROTO.JK02_32S);
  const ofs = is32S ? 16 : 0;   // 32S has 16 extra bytes of cell data (32 vs 24 cells)
  const numCells = is32S ? 32 : 24;

  // --- Cell Voltages: offset 6, numCells × uint16 LE, ×0.001 = V ---
  const cells = [];
  let minV = 100, maxV = -100, minCell = 0, maxCell = 0, totalV = 0, enabledCells = 0;
  for (let i = 0; i < numCells; i++) {
    const raw = jkGet16(view, i * 2 + 6);
    const v = raw * 0.001;  // mV → V
    if (v > 0 && v < 5.0) {
      cells.push({ index: i + 1, mV: raw, V: v });
      totalV += v;
      enabledCells++;
      if (v < minV) { minV = v; minCell = i + 1; }
      if (v > maxV) { maxV = v; maxCell = i + 1; }
    }
  }
  bmsData.cells = cells;
  bmsData.avgCell = enabledCells > 0 ? (totalV / enabledCells) * 1000 : 0;
  bmsData.deltaCell = enabledCells > 0 ? (maxV - minV) * 1000 : 0;
  bmsData.maxCellNo = maxCell;
  bmsData.minCellNo = minCell;

  // --- Cell Resistances: offset 64+ofs, numCells × uint16 LE, ×0.001 = Ω ---
  const resistances = [];
  for (let i = 0; i < numCells; i++) {
    const raw = jkGet16(view, i * 2 + 64 + ofs);
    if (raw > 0 && raw < 65535) {
      resistances.push({ index: i + 1, mOhm: raw });
    }
  }
  bmsData.resistances = resistances;

  // After resistances, 32S doubles the offset
  const ofs2 = ofs * 2;

  // --- MOS Temperature (32S only at 112+ofs2) ---
  if (is32S) {
    bmsData.temps.mos = jkGetS16(view, 112 + ofs2) * 0.1;
  }

  // --- Pack Voltage: offset 118+ofs2, uint32 LE, ×0.001 = V ---
  bmsData.packVoltage = jkGet32(view, 118 + ofs2) * 0.001;

  // --- Pack Current: offset 126+ofs2, int32 LE, ×0.001 = A ---
  const current = jkGetS32(view, 126 + ofs2) * 0.001;
  bmsData.packCurrent = current;
  bmsData.packPower = bmsData.packVoltage * current;

  // --- Temperature Sensor 1: offset 130+ofs2, int16 LE, ×0.1 = °C ---
  bmsData.temps.bat1 = jkGetS16(view, 130 + ofs2) * 0.1;

  // --- Temperature Sensor 2: offset 132+ofs2, int16 LE, ×0.1 = °C ---
  bmsData.temps.bat2 = jkGetS16(view, 132 + ofs2) * 0.1;

  // --- MOS Temp / Errors: offset 134+ofs2 ---
  if (is32S) {
    // 32S: this is errors bitmask (big-endian!)
    const rawErr = (frame[134 + ofs2] << 8) | frame[135 + ofs2];
    bmsData.errorBitmask = rawErr;
    bmsData.errorText = errorBitsToString(rawErr);
  } else {
    bmsData.temps.mos = jkGetS16(view, 134 + ofs2) * 0.1;
  }

  // --- Errors (24S only): offset 136+ofs2 ---
  if (!is32S) {
    const rawErr = (frame[136 + ofs2] << 8) | frame[137 + ofs2];
    bmsData.errorBitmask = rawErr;
    bmsData.errorText = errorBitsToString(rawErr);
  }

  // --- Balance current: offset 138+ofs2, int16 LE, ×0.001 = A ---
  bmsData.balanceCurrent = jkGetS16(view, 138 + ofs2) * 0.001;

  // --- Balance action: offset 140+ofs2 (0=off, 1=charging, 2=discharging) ---
  bmsData.balanceActive = frame[140 + ofs2] !== 0;

  // --- SOC: offset 141+ofs2, uint8, % ---
  bmsData.soc = frame[141 + ofs2];

  // --- Remaining capacity: offset 142+ofs2, uint32 LE, ×0.001 = Ah ---
  bmsData.remainCap = jkGet32(view, 142 + ofs2) * 0.001;

  // --- Full capacity: offset 146+ofs2, uint32 LE, ×0.001 = Ah ---
  bmsData.fullCap = jkGet32(view, 146 + ofs2) * 0.001;

  // --- Cycle count: offset 150+ofs2, uint32 LE ---
  bmsData.cycles = jkGet32(view, 150 + ofs2);

  // --- Cycle capacity: offset 154+ofs2, uint32 LE, ×0.001 = Ah ---
  bmsData.cycleCap = jkGet32(view, 154 + ofs2) * 0.001;

  // --- SOH: offset 158+ofs2, uint8, % ---
  bmsData.soh = frame[158 + ofs2];

  // --- Total runtime: offset 162+ofs2, uint32 LE, seconds ---
  bmsData.runtime = jkGet32(view, 162 + ofs2);

  // --- Charging MOSFET: offset 166+ofs2 ---
  bmsData.chargeMos = frame[166 + ofs2] === 1;

  // --- Discharging MOSFET: offset 167+ofs2 ---
  bmsData.dischargeMos = frame[167 + ofs2] === 1;

  // --- Heating: offset 183+ofs2 ---
  bmsData.heating = frame[183 + ofs2] === 1;

  // --- Temperature sensors 3-5 (32S only) ---
  if (is32S) {
    bmsData.temps.bat3 = jkGetS16(view, 226 + ofs2) * 0.1;
    bmsData.temps.bat4 = jkGetS16(view, 224 + ofs2) * 0.1;
    bmsData.temps.bat5 = jkGetS16(view, 222 + ofs2) * 0.1;
  }

  updateUI();
}

// ============================================================
// JK04 Cell Info Parser
// Based on esphome decode_jk04_cell_info_
// Cell voltages and resistances are IEEE 754 floats!
// ============================================================
function parseJK04CellInfo(frame) {
  const view = new DataView(frame.buffer);
  const numCells = 24;

  // --- Cell Voltages: offset 6, 24 × float32 LE (V) ---
  const cells = [];
  let minV = 100, maxV = -100, minCell = 0, maxCell = 0, totalV = 0, enabledCells = 0;
  for (let i = 0; i < numCells; i++) {
    const v = jkGetFloat(view, i * 4 + 6);
    if (v > 0 && v < 5.0) {
      cells.push({ index: i + 1, mV: Math.round(v * 1000), V: v });
      totalV += v;
      enabledCells++;
      if (v < minV) { minV = v; minCell = i + 1; }
      if (v > maxV) { maxV = v; maxCell = i + 1; }
    }
  }
  bmsData.cells = cells;
  bmsData.avgCell = enabledCells > 0 ? (totalV / enabledCells) * 1000 : 0;
  bmsData.deltaCell = enabledCells > 0 ? (maxV - minV) * 1000 : 0;
  bmsData.maxCellNo = maxCell;
  bmsData.minCellNo = minCell;
  bmsData.packVoltage = totalV;

  // --- Cell Resistances: offset 102, 24 × float32 LE (Ω) ---
  const resistances = [];
  for (let i = 0; i < numCells; i++) {
    const r = jkGetFloat(view, i * 4 + 102);
    if (r > 0 && r < 10) {
      resistances.push({ index: i + 1, mOhm: Math.round(r * 1000) });
    }
  }
  bmsData.resistances = resistances;

  // --- Balancing: offset 220 ---
  bmsData.balanceActive = frame[220] !== 0;

  // --- Balancing current: offset 222, float32 LE (A) ---
  bmsData.balanceCurrent = jkGetFloat(view, 222);

  // --- Uptime: offset 286, uint32 LE (seconds) ---
  bmsData.runtime = jkGet32(view, 286);

  updateUI();
}

// ============================================================
// UI Updates
// ============================================================
function updateUI() {
  const d = bmsData;

  // Pack stats
  const voltage = d.packVoltage;
  const current = d.packCurrent;
  const power = d.packPower !== 0 ? d.packPower : voltage * current;

  document.getElementById('pack-voltage').innerHTML =
    `${voltage.toFixed(1)} <span class="stat-unit">V</span>`;

  const currentEl = document.getElementById('pack-current');
  currentEl.innerHTML = `${current >= 0 ? '+' : ''}${current.toFixed(1)} <span class="stat-unit">A</span>`;
  currentEl.className = 'stat-value ' + (current > 0.1 ? 'green' : current < -0.1 ? 'red' : 'blue');

  document.getElementById('pack-power').innerHTML =
    `${Math.abs(power).toFixed(0)} <span class="stat-unit">W</span>`;

  document.getElementById('pack-cycles').innerHTML =
    `${d.cycles}`;

  // SOC
  const socPct = Math.max(0, Math.min(100, d.soc));
  const socBar = document.getElementById('soc-bar');
  socBar.style.width = Math.max(socPct, 5) + '%';
  socBar.textContent = socPct + '%';

  document.getElementById('soc-remain').textContent = d.remainCap > 0 ? d.remainCap.toFixed(1) : '—';
  document.getElementById('soc-full').textContent = d.fullCap > 0 ? d.fullCap.toFixed(1) : '—';

  // Cell voltages
  updateCellDisplay();

  // Delta
  document.getElementById('cell-delta').textContent = d.deltaCell.toFixed(0);

  // Temperatures
  updateTempDisplay();

  // MOS status
  updateMosStatus('mos-charge', d.chargeMos, 'CHG');
  updateMosStatus('mos-discharge', d.dischargeMos, 'DSG');
  updateMosStatus('mos-balance', d.balanceActive, 'BAL');

  // Alarm / error display
  const alarmEl = document.getElementById('alarm-grid');
  if (alarmEl) {
    if (d.errorBitmask > 0) {
      alarmEl.innerHTML = `<div style="color:var(--red); font-size:13px; grid-column:1/-1; padding:8px">${d.errorText}</div>`;
    } else {
      alarmEl.innerHTML = '<div style="color:var(--green); font-size:13px; grid-column:1/-1; text-align:center; padding:12px">No alarms</div>';
    }
  }
}

function updateCellDisplay() {
  const container = document.getElementById('cells-container');
  const cells = bmsData.cells;
  if (cells.length === 0) return;

  const voltages = cells.map(c => c.mV);
  const min = Math.min(...voltages);
  const max = Math.max(...voltages);
  const avg = bmsData.avgCell;

  // Scale bars: show relative difference
  // Use a range of avg ± 100mV for the bar scale
  const barMin = Math.max(0, avg - 150);
  const barMax = avg + 150;

  let html = '';
  for (const cell of cells) {
    const pct = Math.max(2, Math.min(100, ((cell.mV - barMin) / (barMax - barMin)) * 100));
    const deviation = cell.mV - avg;
    let barClass = 'ok';
    if (deviation > 30) barClass = 'high';
    else if (deviation < -30) barClass = 'low';
    else if (Math.abs(deviation) > 15) barClass = 'mid';

    const isMax = cell.mV === max && cells.length > 1;
    const isMin = cell.mV === min && cells.length > 1;
    const marker = isMax ? ' ▲' : isMin ? ' ▼' : '';

    html += `<div class="cell-row">
      <div class="cell-label">C${cell.index}</div>
      <div class="cell-bar-outer"><div class="cell-bar-inner ${barClass}" style="width:${pct}%"></div></div>
      <div class="cell-value">${(cell.mV / 1000).toFixed(3)}${marker}</div>
    </div>`;
  }
  container.innerHTML = html;
}

function updateTempDisplay() {
  const grid = document.getElementById('temp-grid');
  const t = bmsData.temps;
  if (!t.mos && !t.bat1 && !t.bat2) return;

  const temps = [];
  if (t.mos !== null && t.mos !== undefined) temps.push({ label: 'MOS', value: t.mos });
  if (t.bat1 !== null && t.bat1 !== undefined) temps.push({ label: 'Batt T1', value: t.bat1 });
  if (t.bat2 !== null && t.bat2 !== undefined) temps.push({ label: 'Batt T2', value: t.bat2 });
  if (t.bat3 !== null && t.bat3 !== undefined) temps.push({ label: 'Batt T3', value: t.bat3 });
  if (t.bat4 !== null && t.bat4 !== undefined) temps.push({ label: 'Batt T4', value: t.bat4 });
  if (t.bat5 !== null && t.bat5 !== undefined) temps.push({ label: 'Batt T5', value: t.bat5 });

  let html = '';
  for (const tmp of temps) {
    if (tmp.value === null || isNaN(tmp.value) || Math.abs(tmp.value) > 200) continue;
    const cls = tmp.value > 50 ? 'hot' : tmp.value > 35 ? 'warm' : 'normal';
    html += `<div class="temp-item">
      <div class="temp-label">${tmp.label}</div>
      <div class="temp-value ${cls}">${tmp.value.toFixed(1)}°</div>
    </div>`;
  }
  grid.innerHTML = html || '<div style="color:var(--text3); font-size:13px; grid-column:1/-1; text-align:center; padding:12px">No valid temperature data</div>';
}

function updateMosStatus(id, isOn, label) {
  const el = document.getElementById(id);
  if (!el) return;
  const parent = el.closest('.mos-item');
  parent.className = 'mos-item ' + (isOn ? 'on' : 'off');
  el.textContent = isOn ? 'ON' : 'OFF';
}

// ============================================================
// Hex Dump
// ============================================================
function updateHexDump(frame) {
  const pre = document.getElementById('hex-content');
  let html = '';
  for (let i = 0; i < frame.length; i += 16) {
    const offsetStr = i.toString(16).padStart(4, '0').toUpperCase();
    let hexPart = '';
    let asciiPart = '';
    for (let j = 0; j < 16; j++) {
      if (i + j < frame.length) {
        const byte = frame[i + j];
        let cls = 'data-bytes';
        if (i + j < 4) cls = 'header-bytes';
        else if (i + j === 4) cls = 'header-bytes'; // frame type
        else if (i + j >= frame.length - 4) cls = 'crc-bytes';

        hexPart += `<span class="${cls}">${byte.toString(16).padStart(2, '0').toUpperCase()}</span> `;
        asciiPart += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
      } else {
        hexPart += '   ';
        asciiPart += ' ';
      }
      if (j === 7) hexPart += ' ';
    }
    html += `<span class="offset">${offsetStr}</span>  ${hexPart} |${asciiPart}|\n`;
  }
  pre.innerHTML = html;
}

// ============================================================
// Tab Switching
// ============================================================
function showTab(name, btn) {
  ['cells', 'temps', 'status', 'raw'].forEach(t => {
    const el = document.getElementById('tab-' + t);
    if (el) el.classList.toggle('hidden', t !== name);
  });
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  if (btn) btn.classList.add('active');
}

// ============================================================
// Utilities
// ============================================================
function hex(data) {
  return Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
// Service Worker Registration (PWA)
// ============================================================
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(() => {});
  });
}
</script>
</body>
</html>

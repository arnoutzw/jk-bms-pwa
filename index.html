<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>JK BMS Monitor</title>
<meta name="theme-color" content="#0f172a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<style>
:root {
  --bg: #0f172a; --surface: #1e293b; --surface2: #334155;
  --text: #f1f5f9; --text2: #94a3b8; --text3: #64748b;
  --green: #22c55e; --green-dim: #16a34a; --green-bg: rgba(34,197,94,0.1);
  --red: #ef4444; --red-bg: rgba(239,68,68,0.1);
  --yellow: #eab308; --yellow-bg: rgba(234,179,8,0.1);
  --blue: #3b82f6; --blue-bg: rgba(59,130,246,0.1);
  --orange: #f97316; --orange-bg: rgba(249,115,22,0.1);
  --radius: 12px; --gap: 10px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg); color: var(--text); line-height: 1.5;
  min-height: 100vh; min-height: 100dvh;
  -webkit-font-smoothing: antialiased;
}
.container { max-width: 1200px; margin: 0 auto; padding: 12px; padding-bottom: 80px; }

/* Header */
header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 0; margin-bottom: 12px; border-bottom: 1px solid var(--surface2);
}
header h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.3px; }
header h1 span { color: var(--green); }

/* Buttons */
.btn {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 10px 20px; border: none; border-radius: 8px;
  font-size: 14px; font-weight: 600; cursor: pointer;
  transition: all 0.15s; font-family: inherit;
}
.btn-primary { background: var(--green); color: #000; }
.btn-primary:hover { background: var(--green-dim); }
.btn-primary:disabled { background: var(--surface2); color: var(--text3); cursor: not-allowed; }
.btn-danger { background: var(--red); color: #fff; }
.btn-sm { padding: 6px 14px; font-size: 12px; }
.btn-ghost { background: transparent; color: var(--text2); border: 1px solid var(--surface2); }
.btn-ghost:hover { border-color: var(--text3); }

/* Devices grid */
.devices-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
  gap: 16px;
  align-items: start;
}

/* Add device card */
.add-card {
  background: var(--surface); border: 2px dashed var(--surface2);
  border-radius: var(--radius); padding: 40px 20px;
  text-align: center; min-height: 200px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 12px; transition: border-color 0.2s;
}
.add-card:hover { border-color: var(--text3); }
.add-card p { color: var(--text3); font-size: 13px; }

/* Device panel */
.device-panel {
  background: var(--surface); border-radius: var(--radius);
  border: 2px solid var(--surface2); overflow: hidden;
  transition: border-color 0.3s;
}
.device-panel.slot-0 { border-color: var(--green); }
.device-panel.slot-1 { border-color: var(--blue); }
.device-panel.slot-2 { border-color: var(--orange); }

.panel-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 14px; border-bottom: 1px solid var(--surface2);
}
.panel-header .slot-badge {
  font-size: 10px; font-weight: 700; text-transform: uppercase;
  padding: 2px 8px; border-radius: 4px; letter-spacing: 0.5px;
}
.slot-0 .slot-badge { background: var(--green-bg); color: var(--green); }
.slot-1 .slot-badge { background: var(--blue-bg); color: var(--blue); }
.slot-2 .slot-badge { background: var(--orange-bg); color: var(--orange); }

.panel-header .device-name { font-size: 13px; font-weight: 600; flex: 1; margin: 0 10px; }
.panel-header .status-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--text3); display: inline-block; margin-right: 6px;
  transition: background 0.3s;
}
.panel-header .status-dot.connected { background: var(--green); box-shadow: 0 0 6px var(--green); }
.panel-header .status-dot.connecting { background: var(--yellow); animation: pulse 1s infinite; }
@keyframes pulse { 50% { opacity: 0.4; } }

.panel-body { padding: 12px; }

/* Cards */
.card {
  background: var(--surface2); border-radius: 8px;
  padding: 12px; margin-bottom: var(--gap);
}
.card-title {
  font-size: 10px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.8px; color: var(--text3); margin-bottom: 8px;
}

/* Stats grid */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: var(--gap); }
.stat-card { background: var(--surface2); border-radius: 8px; padding: 10px; }
.stat-label { font-size: 10px; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; }
.stat-value { font-size: 22px; font-weight: 700; letter-spacing: -0.5px; margin: 2px 0 0; }
.stat-unit { font-size: 12px; font-weight: 400; color: var(--text2); }
.stat-value.green { color: var(--green); }
.stat-value.blue { color: var(--blue); }
.stat-value.yellow { color: var(--yellow); }
.stat-value.red { color: var(--red); }

/* SOC gauge */
.soc-card { grid-column: 1 / -1; }
.soc-bar-outer {
  height: 20px; background: rgba(0,0,0,0.3); border-radius: 10px;
  overflow: hidden; margin-top: 6px;
}
.soc-bar-inner {
  height: 100%; border-radius: 10px;
  background: linear-gradient(90deg, var(--red), var(--yellow) 30%, var(--green) 60%);
  transition: width 0.5s ease;
  display: flex; align-items: center; justify-content: flex-end; padding-right: 8px;
  font-size: 11px; font-weight: 700; color: #000; min-width: 36px;
}

/* Cell voltage summary */
.cell-summary {
  display: grid; grid-template-columns: 1fr 1.4fr 1fr; gap: 6px;
  margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.25);
  border-radius: 8px;
}
.cell-summary-item { text-align: center; padding: 6px 4px; border-radius: 6px; }
.cell-summary-item.avg { background: rgba(0,0,0,0.2); }
.cell-summary-label {
  font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px;
  color: var(--text3); margin-bottom: 2px;
}
.cell-summary-value {
  font-size: 18px; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text);
}
.cell-summary-item.avg .cell-summary-value { font-size: 22px; color: var(--green); }

/* Cell voltages */
.cells-container { display: flex; flex-direction: column; gap: 3px; }
.cell-row {
  display: grid; grid-template-columns: 36px 1fr 54px; align-items: center; gap: 6px;
  font-size: 12px;
}
.cell-label { color: var(--text3); font-weight: 500; }
.cell-bar-outer { height: 14px; background: rgba(0,0,0,0.3); border-radius: 3px; overflow: hidden; }
.cell-bar-inner { height: 100%; border-radius: 3px; transition: width 0.3s, background 0.3s; min-width: 2px; }
.cell-bar-inner.low { background: var(--red); }
.cell-bar-inner.mid { background: var(--yellow); }
.cell-bar-inner.ok { background: var(--green); }
.cell-bar-inner.high { background: var(--orange); }
.cell-value { text-align: right; font-variant-numeric: tabular-nums; font-weight: 500; }

/* Temp grid */
.temp-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 6px; }
.temp-item { background: rgba(0,0,0,0.3); border-radius: 6px; padding: 8px; text-align: center; }
.temp-label { font-size: 10px; color: var(--text3); }
.temp-value { font-size: 16px; font-weight: 700; margin-top: 2px; }
.temp-value.hot { color: var(--red); }
.temp-value.warm { color: var(--orange); }
.temp-value.normal { color: var(--green); }

/* MOS status */
.mos-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 10px; }
.mos-item { text-align: center; padding: 8px; border-radius: 6px; border: 1px solid var(--surface2); }
.mos-item.on { border-color: var(--green); background: var(--green-bg); }
.mos-item.off { border-color: var(--red); background: var(--red-bg); }
.mos-label { font-size: 10px; color: var(--text3); }
.mos-state { font-size: 13px; font-weight: 700; margin-top: 2px; }
.mos-item.on .mos-state { color: var(--green); }
.mos-item.off .mos-state { color: var(--red); }

/* Device info rows */
.info-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 4px 0; border-bottom: 1px solid rgba(0,0,0,0.2);
}
.info-row:last-child { border-bottom: none; }
.info-label { font-size: 12px; color: var(--text3); }
.info-value { font-size: 12px; color: var(--text); font-weight: 500; font-family: 'SF Mono', monospace; }

/* Toggle switch */
.toggle-label {
  display: inline-flex; align-items: center; gap: 6px; cursor: pointer; user-select: none;
}
.toggle-label input { display: none; }
.toggle-slider {
  width: 32px; height: 18px; background: var(--surface2); border-radius: 9px;
  position: relative; transition: background 0.2s;
}
.toggle-slider::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 14px; height: 14px; background: var(--text3); border-radius: 50%;
  transition: transform 0.2s, background 0.2s;
}
.toggle-label input:checked + .toggle-slider { background: var(--green); }
.toggle-label input:checked + .toggle-slider::after { transform: translateX(14px); background: #fff; }
.toggle-text { font-size: 12px; color: var(--text2); }

/* Hex dump */
.hex-dump {
  background: rgba(0,0,0,0.3); border-radius: 6px;
  padding: 8px; max-height: 200px; overflow-y: auto;
}
.hex-dump pre {
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 10px; line-height: 1.5; color: var(--text2);
  white-space: pre-wrap; word-break: break-all;
}
.hex-dump .offset { color: var(--text3); }
.hex-dump .header-bytes { color: var(--blue); }
.hex-dump .data-bytes { color: var(--text); }
.hex-dump .crc-bytes { color: var(--yellow); }

/* Log */
.log {
  background: rgba(0,0,0,0.3); border-radius: 6px;
  padding: 8px; max-height: 150px; overflow-y: auto;
  font-family: monospace; font-size: 10px; line-height: 1.5;
}
.log-entry { color: var(--text3); }
.log-entry.info { color: var(--blue); }
.log-entry.ok { color: var(--green); }
.log-entry.warn { color: var(--yellow); }
.log-entry.error { color: var(--red); }

/* Tabs */
.tabs { display: flex; gap: 3px; margin-bottom: var(--gap); }
.tab {
  flex: 1; text-align: center; padding: 6px; border: none;
  background: rgba(0,0,0,0.3); color: var(--text3);
  font-size: 12px; font-weight: 600; cursor: pointer;
  border-radius: 6px; font-family: inherit; transition: all 0.15s;
}
.tab.active { color: var(--green); }
.slot-0 .tab.active { background: var(--green-bg); color: var(--green); }
.slot-1 .tab.active { background: var(--blue-bg); color: var(--blue); }
.slot-2 .tab.active { background: var(--orange-bg); color: var(--orange); }

.hidden { display: none !important; }

/* Browser warning */
.warning-banner {
  background: var(--yellow-bg); border: 1px solid var(--yellow);
  color: var(--yellow); padding: 12px; border-radius: 8px;
  font-size: 13px; margin-bottom: 16px; text-align: center;
}

/* Frame counter */
.frame-counter { font-size: 10px; color: var(--text3); text-align: center; margin-bottom: 6px; }

/* Responsive tweaks for single column */
@media (max-width: 400px) {
  .devices-grid { grid-template-columns: 1fr; }
  .stat-value { font-size: 18px; }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><span>&#9889;</span> JK BMS Monitor</h1>
    <div style="font-size:12px; color:var(--text3)" id="global-status">No devices</div>
  </header>

  <div id="browser-warning" class="warning-banner hidden">
    Web Bluetooth is not supported in this browser. Use Chrome, Edge, or Opera on Android/Desktop.
  </div>

  <div class="devices-grid" id="devices-grid">
    <!-- Add device card (always present, hidden when 3 devices connected) -->
    <div class="add-card" id="add-card">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--text3)" stroke-width="1.5">
        <path d="M6.5 6.5l11 11M6.5 17.5l11-11M12 2v20"/>
        <rect x="4" y="7" width="16" height="10" rx="2"/>
        <rect x="20" y="10" width="2" height="4" rx="0.5" fill="var(--text3)" stroke="none"/>
      </svg>
      <p>Connect a JK BMS via Bluetooth</p>
      <button class="btn btn-primary" id="btn-add" onclick="addDevice()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        Add BMS
      </button>
    </div>
  </div>
</div>

<script>
// ============================================================
// JK BMS BLE Protocol Constants (based on esphome-jk-bms)
// Supports: JK02_24S, JK02_32S, JK04 protocol variants
// ============================================================
const BLE = {
  SERVICE: 0xFFE0,
  CHAR_NOTIFY: 0xFFE1,
  CHAR_WRITE: 0xFFE2,
  CMD_CELL_INFO: 0x96,
  CMD_DEVICE_INFO: 0x97,
  FRAME_SETTINGS: 0x01,
  FRAME_CELL_DATA: 0x02,
  FRAME_DEVICE_INFO: 0x03,
  FRAME_SIZE: 300,
  HEARTBEAT_INTERVAL: 5000,
};

const PROTO = {
  JK02_24S: 'jk02_24s',
  JK02_32S: 'jk02_32s',
  JK04:     'jk04',
};

const ERROR_BITS = [
  'Charge overtemp', 'Charge undertemp', 'Coprocessor comm error',
  'Cell undervoltage', 'Pack undervoltage', 'Discharge overcurrent',
  'Discharge short circuit', 'Discharge overtemp', 'Wire resistance',
  'MOSFET overtemp', 'Cell count mismatch', 'Current sensor anomaly',
  'Cell overvoltage', 'Pack overvoltage', 'Charge overcurrent', 'Charge short circuit',
];

const SLOT_COLORS = ['green', 'blue', 'orange'];
const MAX_SLOTS = 3;

// ============================================================
// Multi-device State
// ============================================================
const slots = [null, null, null]; // Each slot is null or a connection object

function createBmsData() {
  return {
    model: '', firmware: '', hardware: '', serial: '', deviceName: '',
    cells: [], resistances: [],
    avgCell: 0, deltaCell: 0, maxCellNo: 0, minCellNo: 0,
    temps: {}, packVoltage: 0, packCurrent: 0, packPower: 0,
    soc: 0, soh: 0, remainCap: 0, fullCap: 0, cycles: 0, cycleCap: 0, runtime: 0,
    balanceCurrent: 0, chargeMos: false, dischargeMos: false, balanceActive: false,
    heating: false, errorBitmask: 0, errorText: '',
  };
}

function createSlotState() {
  return {
    device: null,
    server: null,
    service: null,
    charNotify: null,
    charWrite: null,
    rxBuffer: [],
    frameCount: 0,
    lastFrameTime: 0,
    reconnecting: false,
    heartbeatTimer: null,
    heartbeatEnabled: false,
    protocolVersion: PROTO.JK02_32S,
    bmsData: createBmsData(),
  };
}

function connectedCount() {
  return slots.filter(s => s !== null).length;
}

function findFreeSlot() {
  for (let i = 0; i < MAX_SLOTS; i++) {
    if (slots[i] === null) return i;
  }
  return -1;
}

// ============================================================
// Element helper
// ============================================================
function el(id, s) { return document.getElementById(id + '-' + s); }

// ============================================================
// Browser check
// ============================================================
if (!navigator.bluetooth) {
  document.getElementById('browser-warning').classList.remove('hidden');
  document.getElementById('btn-add').disabled = true;
}

// ============================================================
// Logging (per-slot)
// ============================================================
function log(s, msg, level = '') {
  const container = el('log', s);
  if (!container) return;
  const ts = new Date().toLocaleTimeString('en', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const div = document.createElement('div');
  div.className = 'log-entry ' + level;
  div.textContent = `[${ts}] ${msg}`;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
  while (container.children.length > 100) container.removeChild(container.firstChild);
}

// ============================================================
// Dynamic UI Generation
// ============================================================
function createDevicePanel(s) {
  const color = SLOT_COLORS[s];
  const html = `
  <div class="device-panel slot-${s}" id="panel-${s}">
    <div class="panel-header">
      <span class="slot-badge">BMS ${s + 1}</span>
      <span class="status-dot connecting" id="dot-${s}"></span>
      <span class="device-name" id="devname-${s}">Connecting...</span>
      <button class="btn btn-danger btn-sm" onclick="disconnectSlot(${s})">&#10005;</button>
    </div>
    <div class="panel-body">
      <div class="frame-counter" id="framecnt-${s}">Waiting for data...</div>

      <!-- SOC -->
      <div class="stat-card soc-card" style="margin-bottom:var(--gap)">
        <div style="display:flex; justify-content:space-between; align-items:baseline">
          <div class="stat-label">State of Charge</div>
          <div style="font-size:11px; color:var(--text2)">
            <span id="soc-remain-${s}">—</span> / <span id="soc-full-${s}">—</span> Ah
          </div>
        </div>
        <div class="soc-bar-outer">
          <div class="soc-bar-inner" id="soc-bar-${s}" style="width:0%">0%</div>
        </div>
      </div>

      <!-- Stats -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">Voltage</div>
          <div class="stat-value blue" id="pack-voltage-${s}">—</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Current</div>
          <div class="stat-value green" id="pack-current-${s}">—</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Power</div>
          <div class="stat-value yellow" id="pack-power-${s}">—</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Cycles</div>
          <div class="stat-value" id="pack-cycles-${s}" style="color:var(--text)">—</div>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" onclick="showTab(${s},'cells',this)">Cells</button>
        <button class="tab" onclick="showTab(${s},'temps',this)">Temps</button>
        <button class="tab" onclick="showTab(${s},'status',this)">Status</button>
        <button class="tab" onclick="showTab(${s},'raw',this)">Raw</button>
      </div>

      <!-- Cells Tab -->
      <div id="tab-cells-${s}" class="card">
        <div style="display:flex; justify-content:space-between; margin-bottom:6px">
          <div class="card-title">Cell Voltages</div>
          <div style="font-size:11px; color:var(--text3)">&#916; <span id="cell-delta-${s}">—</span> mV</div>
        </div>
        <div class="cell-summary" id="cell-summary-${s}">
          <div class="cell-summary-item">
            <div class="cell-summary-label">Min</div>
            <div class="cell-summary-value" id="cell-min-${s}">—</div>
          </div>
          <div class="cell-summary-item avg">
            <div class="cell-summary-label">Avg Cell Voltage</div>
            <div class="cell-summary-value" id="cell-avg-${s}">—</div>
          </div>
          <div class="cell-summary-item">
            <div class="cell-summary-label">Max</div>
            <div class="cell-summary-value" id="cell-max-${s}">—</div>
          </div>
        </div>
        <div class="cells-container" id="cells-container-${s}">
          <div style="text-align:center; color:var(--text3); padding:16px; font-size:12px">Waiting for cell data...</div>
        </div>
      </div>

      <!-- Temps Tab -->
      <div id="tab-temps-${s}" class="card hidden">
        <div class="card-title">Temperatures</div>
        <div class="temp-grid" id="temp-grid-${s}">
          <div style="color:var(--text3); font-size:12px; grid-column:1/-1; text-align:center; padding:10px">Waiting for temperature data...</div>
        </div>
      </div>

      <!-- Status Tab -->
      <div id="tab-status-${s}" class="card hidden">
        <div class="card-title">Device Info</div>
        <div id="devinfo-${s}" style="margin-bottom:10px">
          <div style="color:var(--text3); font-size:12px; text-align:center; padding:6px">Waiting for device info...</div>
        </div>
        <div class="card-title">MOS Status</div>
        <div class="mos-grid">
          <div class="mos-item" id="mos-chg-wrap-${s}"><div class="mos-label">Charge</div><div class="mos-state" id="mos-chg-${s}">—</div></div>
          <div class="mos-item" id="mos-dsg-wrap-${s}"><div class="mos-label">Discharge</div><div class="mos-state" id="mos-dsg-${s}">—</div></div>
          <div class="mos-item" id="mos-bal-wrap-${s}"><div class="mos-label">Balance</div><div class="mos-state" id="mos-bal-${s}">—</div></div>
        </div>
        <div class="card-title" style="margin-top:10px">Alarms</div>
        <div id="alarms-${s}" style="font-size:12px; color:var(--green); text-align:center; padding:8px">No alarms</div>
      </div>

      <!-- Raw Tab -->
      <div id="tab-raw-${s}" class="card hidden">
        <div class="card-title">Raw Frame Data</div>
        <div style="display:flex; gap:4px; margin-bottom:6px; flex-wrap:wrap; align-items:center">
          <button class="btn btn-ghost btn-sm" onclick="sendActivate(${s})">Activate</button>
          <button class="btn btn-ghost btn-sm" onclick="sendDeviceInfoCmd(${s})">Dev Info</button>
          <label class="toggle-label" style="margin-left:auto">
            <input type="checkbox" id="hb-toggle-${s}" onchange="toggleHeartbeat(${s},this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-text">HB</span>
          </label>
        </div>
        <div class="hex-dump" id="hexdump-${s}">
          <pre id="hexcontent-${s}">No data received yet</pre>
        </div>
        <div class="card-title" style="margin-top:10px">Event Log</div>
        <div class="log" id="log-${s}"></div>
      </div>
    </div>
  </div>`;

  const addCard = document.getElementById('add-card');
  addCard.insertAdjacentHTML('beforebegin', html);
}

function removeDevicePanel(s) {
  const panel = document.getElementById('panel-' + s);
  if (panel) panel.remove();
}

function updateGlobalStatus() {
  const n = connectedCount();
  const statusEl = document.getElementById('global-status');
  statusEl.textContent = n === 0 ? 'No devices' : `${n} device${n > 1 ? 's' : ''} connected`;

  // Show/hide add card
  const addCard = document.getElementById('add-card');
  if (n >= MAX_SLOTS) {
    addCard.classList.add('hidden');
  } else {
    addCard.classList.remove('hidden');
  }
}

// ============================================================
// BLE Connection (per-slot)
// ============================================================
async function addDevice() {
  const s = findFreeSlot();
  if (s === -1) { alert('Maximum 3 devices connected'); return; }

  try {
    const state = createSlotState();
    slots[s] = state;

    // Create UI panel
    createDevicePanel(s);
    updateGlobalStatus();

    log(s, 'Scanning for JK BMS devices...', 'info');

    state.device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [BLE.SERVICE] }],
      optionalServices: [BLE.SERVICE],
    });

    log(s, `Selected: ${state.device.name || 'Unknown'} (${state.device.id.slice(0,8)})`, 'ok');
    state.device.addEventListener('gattserverdisconnected', () => onDisconnected(s));

    await connectSlot(s);
  } catch (err) {
    if (err.name === 'NotFoundError') {
      // User cancelled scan — remove the slot
      removeDevicePanel(s);
      slots[s] = null;
      updateGlobalStatus();
    } else {
      log(s, `Scan error: ${err.message}`, 'error');
      setSlotStatus(s, 'disconnected');
    }
  }
}

async function connectSlot(s) {
  const state = slots[s];
  if (!state || !state.device) return;

  try {
    setSlotStatus(s, 'connecting');
    log(s, 'Connecting to GATT server...', 'info');

    state.server = await state.device.gatt.connect();
    log(s, 'GATT connected', 'ok');

    state.service = await state.server.getPrimaryService(BLE.SERVICE);
    log(s, 'Service 0xFFE0 found', 'ok');

    state.charNotify = await state.service.getCharacteristic(BLE.CHAR_NOTIFY);
    log(s, 'Notify char 0xFFE1 found', 'ok');

    try {
      state.charWrite = await state.service.getCharacteristic(BLE.CHAR_WRITE);
      log(s, 'Write char 0xFFE2 found', 'ok');
    } catch {
      state.charWrite = state.charNotify;
      log(s, 'Using 0xFFE1 for write (0xFFE2 not found)', 'warn');
    }

    await state.charNotify.startNotifications();
    state.charNotify.addEventListener('characteristicvaluechanged', (event) => onNotification(s, event));
    log(s, 'Notifications enabled', 'ok');

    setSlotStatus(s, 'connected');
    const nameEl = el('devname', s);
    if (nameEl) nameEl.textContent = state.device.name || 'JK BMS';

    // Request device info first (triggers protocol auto-detection)
    await sleep(500);
    await sendDeviceInfoCmd(s);

    // Then request cell info
    await sleep(300);
    await sendActivate(s);

    // Start heartbeat if enabled
    startHeartbeat(s);

  } catch (err) {
    log(s, `Connection error: ${err.message}`, 'error');
    setSlotStatus(s, 'disconnected');
  }
}

function onDisconnected(s) {
  const state = slots[s];
  if (!state) return;

  log(s, 'Device disconnected', 'warn');
  setSlotStatus(s, 'disconnected');
  if (state.heartbeatTimer) { clearInterval(state.heartbeatTimer); state.heartbeatTimer = null; }
  state.charNotify = null;
  state.charWrite = null;

  if (!state.reconnecting) {
    state.reconnecting = true;
    log(s, 'Attempting reconnect in 3s...', 'info');
    setTimeout(async () => {
      if (!slots[s]) return; // slot was freed
      state.reconnecting = false;
      if (state.device && state.device.gatt) {
        try { await connectSlot(s); } catch { log(s, 'Reconnect failed', 'error'); }
      }
    }, 3000);
  }
}

async function disconnectSlot(s) {
  const state = slots[s];
  if (!state) return;

  if (state.heartbeatTimer) { clearInterval(state.heartbeatTimer); state.heartbeatTimer = null; }
  state.reconnecting = true; // Prevent auto-reconnect
  if (state.device && state.device.gatt.connected) {
    state.device.gatt.disconnect();
  }

  removeDevicePanel(s);
  slots[s] = null;
  updateGlobalStatus();
}

function setSlotStatus(s, status) {
  const dot = el('dot', s);
  if (dot) {
    dot.className = 'status-dot ' + status;
  }
}

// ============================================================
// BLE Commands (per-slot)
// ============================================================
function buildCommand(cmd) {
  const frame = new Uint8Array(20);
  frame[0] = 0xAA; frame[1] = 0x55; frame[2] = 0x90; frame[3] = 0xEB;
  frame[4] = cmd;
  let sum = 0;
  for (let i = 0; i < 19; i++) sum += frame[i];
  frame[19] = sum & 0xFF;
  return frame;
}

async function sendCmd(s, data) {
  const state = slots[s];
  if (!state || !state.charWrite) { log(s, 'Not connected', 'error'); return; }
  try {
    await state.charWrite.writeValueWithoutResponse(data);
    log(s, `TX: ${hex(data)}`, 'info');
  } catch {
    try {
      await state.charWrite.writeValue(data);
      log(s, `TX (with response): ${hex(data)}`, 'info');
    } catch (err2) {
      log(s, `Write failed: ${err2.message}`, 'error');
    }
  }
}

async function sendActivate(s) {
  log(s, 'Sending cell info request (0x96)', 'info');
  await sendCmd(s, buildCommand(BLE.CMD_CELL_INFO));
}

async function sendDeviceInfoCmd(s) {
  log(s, 'Sending device info command (0x97)', 'info');
  await sendCmd(s, buildCommand(BLE.CMD_DEVICE_INFO));
}

function startHeartbeat(s) {
  const state = slots[s];
  if (!state) return;
  if (state.heartbeatTimer) { clearInterval(state.heartbeatTimer); state.heartbeatTimer = null; }

  const toggle = el('hb-toggle', s);
  if (toggle && toggle.checked) {
    state.heartbeatTimer = setInterval(async () => {
      if (state.charWrite) {
        try { await sendActivate(s); } catch {}
      }
    }, BLE.HEARTBEAT_INTERVAL);
    log(s, 'Heartbeat started (every 5s)', 'ok');
  }
}

function toggleHeartbeat(s, enabled) {
  const state = slots[s];
  if (!state) return;
  if (enabled) {
    startHeartbeat(s);
  } else {
    if (state.heartbeatTimer) { clearInterval(state.heartbeatTimer); state.heartbeatTimer = null; }
    log(s, 'Heartbeat stopped', 'warn');
  }
}

// ============================================================
// Notification Handler & Frame Assembly (per-slot)
// ============================================================
function onNotification(s, event) {
  const state = slots[s];
  if (!state) return;

  const value = new Uint8Array(event.target.value.buffer);
  for (let i = 0; i < value.length; i++) state.rxBuffer.push(value[i]);
  extractFrames(s);
}

function extractFrames(s) {
  const state = slots[s];
  if (!state) return;

  while (state.rxBuffer.length >= BLE.FRAME_SIZE) {
    let headerIdx = -1;
    for (let i = 0; i <= state.rxBuffer.length - 4; i++) {
      if (state.rxBuffer[i] === 0x55 && state.rxBuffer[i+1] === 0xAA &&
          state.rxBuffer[i+2] === 0xEB && state.rxBuffer[i+3] === 0x90) {
        headerIdx = i;
        break;
      }
    }

    if (headerIdx === -1) {
      if (state.rxBuffer.length > 3) state.rxBuffer = state.rxBuffer.slice(-3);
      return;
    }

    if (headerIdx > 0) state.rxBuffer = state.rxBuffer.slice(headerIdx);
    if (state.rxBuffer.length < BLE.FRAME_SIZE) return;

    const frame = new Uint8Array(state.rxBuffer.slice(0, BLE.FRAME_SIZE));
    state.rxBuffer = state.rxBuffer.slice(BLE.FRAME_SIZE);

    let crcCalc = 0;
    for (let i = 0; i < BLE.FRAME_SIZE - 1; i++) crcCalc += frame[i];
    crcCalc &= 0xFF;
    const crcRemote = frame[BLE.FRAME_SIZE - 1];

    if (crcCalc !== crcRemote) {
      log(s, `CRC mismatch: calc=0x${crcCalc.toString(16)} != recv=0x${crcRemote.toString(16)}`, 'warn');
      continue;
    }

    processFrame(s, frame);
  }
}

// ============================================================
// Frame Processing (per-slot)
// ============================================================
function processFrame(s, frame) {
  const state = slots[s];
  if (!state || frame.length < 6) return;

  state.frameCount++;
  state.lastFrameTime = Date.now();
  const frameType = frame[4];

  const cntEl = el('framecnt', s);
  if (cntEl) cntEl.textContent =
    `Frame #${state.frameCount} | Type: 0x${frameType.toString(16).padStart(2,'0')} | ${frame.length}B | ${state.protocolVersion}`;

  updateHexDump(s, frame);

  switch (frameType) {
    case BLE.FRAME_SETTINGS:
      log(s, `Settings frame (${frame.length} bytes)`, 'info');
      break;
    case BLE.FRAME_CELL_DATA:
      parseCellData(s, frame);
      break;
    case BLE.FRAME_DEVICE_INFO:
      parseDeviceInfo(s, frame);
      break;
    default:
      log(s, `Unknown frame type 0x${frameType.toString(16)}`, 'warn');
  }
}

// ============================================================
// Data Helpers
// ============================================================
function jkGet16(view, i) { return view.getUint16(i, true); }
function jkGet32(view, i) { return view.getUint32(i, true); }
function jkGetS16(view, i) { return view.getInt16(i, true); }
function jkGetS32(view, i) { return view.getInt32(i, true); }
function jkGetFloat(view, i) { return view.getFloat32(i, true); }

function readString(frame, start, maxLen) {
  let s = '';
  for (let i = start; i < Math.min(start + maxLen, frame.length); i++) {
    if (frame[i] === 0) break;
    if (frame[i] >= 0x20 && frame[i] <= 0x7E) s += String.fromCharCode(frame[i]);
  }
  return s;
}

function errorBitsToString(bitmask) {
  const errors = [];
  for (let i = 0; i < ERROR_BITS.length; i++) {
    if (bitmask & (1 << i)) errors.push(ERROR_BITS[i]);
  }
  return errors.length > 0 ? errors.join(', ') : 'None';
}

// ============================================================
// Device Info Parser (Frame Type 0x03)
// ============================================================
function parseDeviceInfo(s, frame) {
  const state = slots[s];
  if (!state || frame.length < 70) return;

  const view = new DataView(frame.buffer);
  const d = state.bmsData;

  d.model = readString(frame, 6, 16);
  d.hardware = readString(frame, 22, 8);
  d.firmware = readString(frame, 30, 8);
  const uptimeS = jkGet32(view, 38);
  const powerOnCount = jkGet32(view, 42);
  d.deviceName = readString(frame, 46, 16);
  const passcode = readString(frame, 62, 16);
  const mfgDate = readString(frame, 78, 8);
  d.serial = readString(frame, 86, 11);

  // Auto-detect protocol
  const model = d.model;
  if (model.startsWith('JK_') || model.includes('PB')) {
    state.protocolVersion = PROTO.JK02_32S;
    log(s, `Protocol: JK02_32S (model: ${model})`, 'ok');
  } else if (model.startsWith('JK-B') && /\d{2}S$/.test(model)) {
    const hwMajor = parseInt(d.hardware);
    if (hwMajor >= 11) {
      state.protocolVersion = PROTO.JK02_32S;
      log(s, `Protocol: JK02_32S (HW ${d.hardware})`, 'ok');
    } else if (hwMajor >= 3 && hwMajor < 11) {
      state.protocolVersion = PROTO.JK04;
      log(s, `Protocol: JK04 (HW ${d.hardware})`, 'ok');
    } else {
      state.protocolVersion = PROTO.JK02_24S;
      log(s, `Protocol: JK02_24S (HW ${d.hardware})`, 'ok');
    }
  }

  // Update UI
  const nameEl = el('devname', s);
  if (nameEl) nameEl.textContent = d.deviceName || d.model || state.device?.name || 'JK BMS';

  const infoEl = el('devinfo', s);
  if (infoEl) {
    infoEl.innerHTML = `
      <div class="info-row"><span class="info-label">Model</span><span class="info-value">${d.model || '—'}</span></div>
      <div class="info-row"><span class="info-label">Hardware</span><span class="info-value">${d.hardware || '—'}</span></div>
      <div class="info-row"><span class="info-label">Firmware</span><span class="info-value">${d.firmware || '—'}</span></div>
      <div class="info-row"><span class="info-label">Serial</span><span class="info-value">${d.serial || '—'}</span></div>
      <div class="info-row"><span class="info-label">Name</span><span class="info-value">${d.deviceName || '—'}</span></div>
      <div class="info-row"><span class="info-label">Protocol</span><span class="info-value">${state.protocolVersion}</span></div>
    `;
  }

  log(s, `Model: ${d.model} | FW: ${d.firmware} | SN: ${d.serial}`, 'ok');
}

// ============================================================
// Cell Data Parser (Frame Type 0x02)
// ============================================================
function parseCellData(s, frame) {
  const state = slots[s];
  if (!state || frame.length < 200) return;

  if (state.protocolVersion === PROTO.JK04) {
    parseJK04CellInfo(s, frame);
  } else {
    parseJK02CellInfo(s, frame);
  }
}

// ============================================================
// JK02 Cell Info Parser (24S and 32S)
// ============================================================
function parseJK02CellInfo(s, frame) {
  const state = slots[s];
  if (!state) return;
  const view = new DataView(frame.buffer);
  const d = state.bmsData;
  const is32S = (state.protocolVersion === PROTO.JK02_32S);
  const ofs = is32S ? 16 : 0;
  const numCells = is32S ? 32 : 24;

  // Cell Voltages: offset 6, numCells × uint16 LE, ×0.001 = V
  const cells = [];
  let minV = 100, maxV = -100, minCell = 0, maxCell = 0, totalV = 0, enabledCells = 0;
  for (let i = 0; i < numCells; i++) {
    const raw = jkGet16(view, i * 2 + 6);
    const v = raw * 0.001;
    if (v > 0 && v < 5.0) {
      cells.push({ index: i + 1, mV: raw, V: v });
      totalV += v;
      enabledCells++;
      if (v < minV) { minV = v; minCell = i + 1; }
      if (v > maxV) { maxV = v; maxCell = i + 1; }
    }
  }
  d.cells = cells;
  d.avgCell = enabledCells > 0 ? (totalV / enabledCells) * 1000 : 0;
  d.deltaCell = enabledCells > 0 ? (maxV - minV) * 1000 : 0;
  d.maxCellNo = maxCell;
  d.minCellNo = minCell;

  // Cell Resistances: offset 64+ofs
  const resistances = [];
  for (let i = 0; i < numCells; i++) {
    const raw = jkGet16(view, i * 2 + 64 + ofs);
    if (raw > 0 && raw < 65535) resistances.push({ index: i + 1, mOhm: raw });
  }
  d.resistances = resistances;

  const ofs2 = ofs * 2;

  if (is32S) d.temps.mos = jkGetS16(view, 112 + ofs2) * 0.1;

  d.packVoltage = jkGet32(view, 118 + ofs2) * 0.001;
  const current = jkGetS32(view, 126 + ofs2) * 0.001;
  d.packCurrent = current;
  d.packPower = d.packVoltage * current;

  d.temps.bat1 = jkGetS16(view, 130 + ofs2) * 0.1;
  d.temps.bat2 = jkGetS16(view, 132 + ofs2) * 0.1;

  if (is32S) {
    const rawErr = (frame[134 + ofs2] << 8) | frame[135 + ofs2];
    d.errorBitmask = rawErr;
    d.errorText = errorBitsToString(rawErr);
  } else {
    d.temps.mos = jkGetS16(view, 134 + ofs2) * 0.1;
    const rawErr = (frame[136 + ofs2] << 8) | frame[137 + ofs2];
    d.errorBitmask = rawErr;
    d.errorText = errorBitsToString(rawErr);
  }

  d.balanceCurrent = jkGetS16(view, 138 + ofs2) * 0.001;
  d.balanceActive = frame[140 + ofs2] !== 0;
  d.soc = frame[141 + ofs2];
  d.remainCap = jkGet32(view, 142 + ofs2) * 0.001;
  d.fullCap = jkGet32(view, 146 + ofs2) * 0.001;
  d.cycles = jkGet32(view, 150 + ofs2);
  d.cycleCap = jkGet32(view, 154 + ofs2) * 0.001;
  d.soh = frame[158 + ofs2];
  d.runtime = jkGet32(view, 162 + ofs2);
  d.chargeMos = frame[166 + ofs2] === 1;
  d.dischargeMos = frame[167 + ofs2] === 1;
  d.heating = frame[183 + ofs2] === 1;

  if (is32S) {
    d.temps.bat3 = jkGetS16(view, 226 + ofs2) * 0.1;
    d.temps.bat4 = jkGetS16(view, 224 + ofs2) * 0.1;
    d.temps.bat5 = jkGetS16(view, 222 + ofs2) * 0.1;
  }

  updateSlotUI(s);
}

// ============================================================
// JK04 Cell Info Parser
// ============================================================
function parseJK04CellInfo(s, frame) {
  const state = slots[s];
  if (!state) return;
  const view = new DataView(frame.buffer);
  const d = state.bmsData;
  const numCells = 24;

  const cells = [];
  let minV = 100, maxV = -100, minCell = 0, maxCell = 0, totalV = 0, enabledCells = 0;
  for (let i = 0; i < numCells; i++) {
    const v = jkGetFloat(view, i * 4 + 6);
    if (v > 0 && v < 5.0) {
      cells.push({ index: i + 1, mV: Math.round(v * 1000), V: v });
      totalV += v;
      enabledCells++;
      if (v < minV) { minV = v; minCell = i + 1; }
      if (v > maxV) { maxV = v; maxCell = i + 1; }
    }
  }
  d.cells = cells;
  d.avgCell = enabledCells > 0 ? (totalV / enabledCells) * 1000 : 0;
  d.deltaCell = enabledCells > 0 ? (maxV - minV) * 1000 : 0;
  d.maxCellNo = maxCell;
  d.minCellNo = minCell;
  d.packVoltage = totalV;

  const resistances = [];
  for (let i = 0; i < numCells; i++) {
    const r = jkGetFloat(view, i * 4 + 102);
    if (r > 0 && r < 10) resistances.push({ index: i + 1, mOhm: Math.round(r * 1000) });
  }
  d.resistances = resistances;

  d.balanceActive = frame[220] !== 0;
  d.balanceCurrent = jkGetFloat(view, 222);
  d.runtime = jkGet32(view, 286);

  updateSlotUI(s);
}

// ============================================================
// UI Updates (per-slot)
// ============================================================
function updateSlotUI(s) {
  const state = slots[s];
  if (!state) return;
  const d = state.bmsData;

  const voltage = d.packVoltage;
  const current = d.packCurrent;
  const power = d.packPower !== 0 ? d.packPower : voltage * current;

  const voltEl = el('pack-voltage', s);
  if (voltEl) voltEl.innerHTML = `${voltage.toFixed(1)} <span class="stat-unit">V</span>`;

  const curEl = el('pack-current', s);
  if (curEl) {
    curEl.innerHTML = `${current >= 0 ? '+' : ''}${current.toFixed(1)} <span class="stat-unit">A</span>`;
    curEl.className = 'stat-value ' + (current > 0.1 ? 'green' : current < -0.1 ? 'red' : 'blue');
  }

  const powEl = el('pack-power', s);
  if (powEl) powEl.innerHTML = `${Math.abs(power).toFixed(0)} <span class="stat-unit">W</span>`;

  const cycEl = el('pack-cycles', s);
  if (cycEl) cycEl.textContent = d.cycles;

  // SOC
  const socPct = Math.max(0, Math.min(100, d.soc));
  const socBar = el('soc-bar', s);
  if (socBar) {
    socBar.style.width = Math.max(socPct, 5) + '%';
    socBar.textContent = socPct + '%';
  }
  const remEl = el('soc-remain', s);
  if (remEl) remEl.textContent = d.remainCap > 0 ? d.remainCap.toFixed(1) : '—';
  const fullEl = el('soc-full', s);
  if (fullEl) fullEl.textContent = d.fullCap > 0 ? d.fullCap.toFixed(1) : '—';

  // Cells
  updateCellDisplay(s);

  const deltaEl = el('cell-delta', s);
  if (deltaEl) deltaEl.textContent = d.deltaCell.toFixed(0);

  // Cell voltage summary (avg / min / max)
  const avgEl = el('cell-avg', s);
  if (avgEl) avgEl.textContent = d.avgCell > 0 ? (d.avgCell / 1000).toFixed(3) + ' V' : '—';
  const minEl = el('cell-min', s);
  if (minEl && d.cells.length > 0) {
    const minMv = Math.min(...d.cells.map(c => c.mV));
    minEl.textContent = (minMv / 1000).toFixed(3) + ' V';
  }
  const maxEl = el('cell-max', s);
  if (maxEl && d.cells.length > 0) {
    const maxMv = Math.max(...d.cells.map(c => c.mV));
    maxEl.textContent = (maxMv / 1000).toFixed(3) + ' V';
  }

  // Temps
  updateTempDisplay(s);

  // MOS
  updateMos(s, 'chg', d.chargeMos);
  updateMos(s, 'dsg', d.dischargeMos);
  updateMos(s, 'bal', d.balanceActive);

  // Alarms
  const alarmEl = el('alarms', s);
  if (alarmEl) {
    if (d.errorBitmask > 0) {
      alarmEl.style.color = 'var(--red)';
      alarmEl.textContent = d.errorText;
    } else {
      alarmEl.style.color = 'var(--green)';
      alarmEl.textContent = 'No alarms';
    }
  }
}

function updateCellDisplay(s) {
  const state = slots[s];
  if (!state) return;
  const container = el('cells-container', s);
  if (!container) return;
  const cells = state.bmsData.cells;
  if (cells.length === 0) return;

  const voltages = cells.map(c => c.mV);
  const min = Math.min(...voltages);
  const max = Math.max(...voltages);
  const avg = state.bmsData.avgCell;
  const barMin = Math.max(0, avg - 150);
  const barMax = avg + 150;

  let html = '';
  for (const cell of cells) {
    const pct = Math.max(2, Math.min(100, ((cell.mV - barMin) / (barMax - barMin)) * 100));
    const deviation = cell.mV - avg;
    let barClass = 'ok';
    if (deviation > 30) barClass = 'high';
    else if (deviation < -30) barClass = 'low';
    else if (Math.abs(deviation) > 15) barClass = 'mid';

    const isMax = cell.mV === max && cells.length > 1;
    const isMin = cell.mV === min && cells.length > 1;
    const marker = isMax ? ' ▲' : isMin ? ' ▼' : '';

    html += `<div class="cell-row">
      <div class="cell-label">C${cell.index}</div>
      <div class="cell-bar-outer"><div class="cell-bar-inner ${barClass}" style="width:${pct}%"></div></div>
      <div class="cell-value">${(cell.mV / 1000).toFixed(3)}${marker}</div>
    </div>`;
  }
  container.innerHTML = html;
}

function updateTempDisplay(s) {
  const state = slots[s];
  if (!state) return;
  const grid = el('temp-grid', s);
  if (!grid) return;
  const t = state.bmsData.temps;
  if (!t.mos && !t.bat1 && !t.bat2) return;

  const temps = [];
  if (t.mos != null) temps.push({ label: 'MOS', value: t.mos });
  if (t.bat1 != null) temps.push({ label: 'T1', value: t.bat1 });
  if (t.bat2 != null) temps.push({ label: 'T2', value: t.bat2 });
  if (t.bat3 != null) temps.push({ label: 'T3', value: t.bat3 });
  if (t.bat4 != null) temps.push({ label: 'T4', value: t.bat4 });
  if (t.bat5 != null) temps.push({ label: 'T5', value: t.bat5 });

  let html = '';
  for (const tmp of temps) {
    if (tmp.value == null || isNaN(tmp.value) || Math.abs(tmp.value) > 200) continue;
    const cls = tmp.value > 50 ? 'hot' : tmp.value > 35 ? 'warm' : 'normal';
    html += `<div class="temp-item">
      <div class="temp-label">${tmp.label}</div>
      <div class="temp-value ${cls}">${tmp.value.toFixed(1)}°</div>
    </div>`;
  }
  grid.innerHTML = html || '<div style="color:var(--text3); font-size:12px; grid-column:1/-1; text-align:center; padding:10px">No temp data</div>';
}

function updateMos(s, key, isOn) {
  const stateEl = el('mos-' + key, s);
  const wrapEl = el('mos-' + key + '-wrap', s);
  if (!stateEl || !wrapEl) return;
  wrapEl.className = 'mos-item ' + (isOn ? 'on' : 'off');
  stateEl.textContent = isOn ? 'ON' : 'OFF';
}

// ============================================================
// Hex Dump (per-slot)
// ============================================================
function updateHexDump(s, frame) {
  const pre = el('hexcontent', s);
  if (!pre) return;
  let html = '';
  for (let i = 0; i < frame.length; i += 16) {
    const offsetStr = i.toString(16).padStart(4, '0').toUpperCase();
    let hexPart = '';
    let asciiPart = '';
    for (let j = 0; j < 16; j++) {
      if (i + j < frame.length) {
        const byte = frame[i + j];
        let cls = 'data-bytes';
        if (i + j < 4) cls = 'header-bytes';
        else if (i + j === 4) cls = 'header-bytes';
        else if (i + j >= frame.length - 4) cls = 'crc-bytes';
        hexPart += `<span class="${cls}">${byte.toString(16).padStart(2, '0').toUpperCase()}</span> `;
        asciiPart += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
      } else {
        hexPart += '   ';
        asciiPart += ' ';
      }
      if (j === 7) hexPart += ' ';
    }
    html += `<span class="offset">${offsetStr}</span>  ${hexPart} |${asciiPart}|\n`;
  }
  pre.innerHTML = html;
}

// ============================================================
// Tab Switching (per-slot)
// ============================================================
function showTab(s, name, btn) {
  ['cells', 'temps', 'status', 'raw'].forEach(t => {
    const tabEl = el('tab-' + t, s);
    if (tabEl) tabEl.classList.toggle('hidden', t !== name);
  });
  // Update tab buttons within this panel
  const panel = document.getElementById('panel-' + s);
  if (panel) {
    panel.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    if (btn) btn.classList.add('active');
  }
}

// ============================================================
// Utilities
// ============================================================
function hex(data) {
  return Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ============================================================
// Service Worker (PWA)
// ============================================================
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(() => {});
  });
}
</script>
</body>
</html>
